---
:cmock:
  :plugins:
  - # no plugins

:systest:
  :types: |
    typedef unsigned short U16;
    typedef struct _POINT_T
    {
      int x;
      int y;
    } POINT_T;

  :mockable: |
    // typedef edge case; must be in mockable.h for test to compile
    typedef void VOID_TYPE_CRAZINESS;
    
    U16  *ptr_return1(int a);
    U16*  ptr_return2(int a);
    U16 * ptr_return3(int a);

    void var_args1(int a, ...);
    void var_args2(int a, int b, ...);
    
    VOID_TYPE_CRAZINESS void_type_craziness1(int * a, int *b, int* c);
    void void_type_craziness2(VOID_TYPE_CRAZINESS);
    
    char
    crazy_multiline(
      int a,
      unsigned int b);
    
    unsigned int** ptr_ptr_return1(unsigned int** a);
    unsigned int* *ptr_ptr_return2(unsigned int* *a);
    unsigned int **ptr_ptr_return3(unsigned int **a);
    unsigned int ** ptr_ptr_return4(unsigned int ** a);

    unsigned long int incredible_descriptors(register const unsigned short a);
    
  :source: 
    :header: |
      U16* exercise_return_pointers(int a);
      void exercise_var_args(int a, int b);
      void exercise_arglist_pointers(void);
      char exercise_multiline_declarations(int a, unsigned int b);
      void exercise_double_pointers(unsigned int a);
      int  exercise_many_descriptors(int a);      
      
    :code: |
      int A, B, C;
      
      U16* exercise_return_pointers(int a)
      {
        ptr_return1(a);
        ptr_return2(a);
        return ptr_return3(a);
      }    

      void exercise_var_args(int a, int b)
      {
        var_args1(a, 3);
        var_args2(a, b, 'c');
      }
      
      void exercise_arglist_pointers(void)
      {
        void_type_craziness1(&A, &B, &C);
        void_type_craziness2();
      }

      char exercise_multiline_declarations(int a, unsigned int b)
      {
        return crazy_multiline(a, b);
      }

      void exercise_double_pointers(unsigned int a)
      {
        ptr_ptr_return1((unsigned int**)a);
        ptr_ptr_return2((unsigned int**)a);
        ptr_ptr_return3((unsigned int**)a);
        ptr_ptr_return4((unsigned int**)a);
      }
      
      int exercise_many_descriptors(int a)
      {
        return (int)incredible_descriptors((unsigned short)a);
      }
      
  :tests:
    :common: |
      void setUp(void) {}
      void tearDown(void) {}
      
      extern int A, B, C;
    :units:
    - :pass: TRUE
      :should: 'execute simple pointer return value check'
      :code: |
        test()
        {
          U16 retval;
          ptr_return1_ExpectAndReturn(2, NULL);
          ptr_return2_ExpectAndReturn(2, NULL);
          ptr_return3_ExpectAndReturn(2, &retval);
          TEST_ASSERT_EQUAL(&retval, exercise_return_pointers(2));
        }
        
    - :pass: TRUE
      :should: 'ignore var args in expect prototype generation'
      :code: |
        test()
        {
          var_args1_Expect(2);
          var_args2_Expect(2, 3);
          exercise_var_args(2, 3);
        }
        
    - :pass: TRUE
      :should: "not process a typedef'd void as anything other than void"
      :code: |
        test()
        {
          void_type_craziness1_Expect(&A, &B, &C);
          void_type_craziness2_Expect();
          exercise_arglist_pointers();
        }

    - :pass: TRUE
      :should: 'successfully mock crazy multline function prototypes'
      :code: |
        test()
        {
          crazy_multiline_ExpectAndReturn(-10, 11, 'z');
          TEST_ASSERT_EQUAL('z', exercise_multiline_declarations(-10, 11));
        }

    - :pass: TRUE
      :should: 'mock double pointers just fine'
      :code: |
        test()
        {
          ptr_ptr_return1_ExpectAndReturn((unsigned int**)A, (unsigned int**)B);
          ptr_ptr_return2_ExpectAndReturn((unsigned int**)A, (unsigned int**)B);
          ptr_ptr_return3_ExpectAndReturn((unsigned int**)A, (unsigned int**)B);
          ptr_ptr_return4_ExpectAndReturn((unsigned int**)A, (unsigned int**)B);
          exercise_double_pointers((unsigned int)A);
        }

    - :pass: TRUE
      :should: 'mock prototypes with long lists of return and parameter type descriptors'
      :code: |
        test()
        {
          incredible_descriptors_ExpectAndReturn(888, 777);
          TEST_ASSERT_EQUAL(777, exercise_many_descriptors(888));
        }


...
