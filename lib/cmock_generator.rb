$here = File.dirname __FILE__

class CMockGenerator

  def initialize(config, module_name, file_writer, utils, plugins=[])
    @config = config
    @file_writer = file_writer
    @tab = @config.tab
    @module_name = module_name
    @mock_name = "Mock" + @module_name
    @utils = utils
    @plugins = plugins
  end

  def create_mock(parsed_stuff)
    create_mock_header_file(parsed_stuff)
    create_mock_source_file(parsed_stuff)
  end

  def create_mock_header_file(parsed_stuff)
    @file_writer.create_file(@mock_name + ".h") do |file, filename|
      create_mock_header_header(file, filename)
      create_mock_header_externs(file, parsed_stuff)
      parsed_stuff[:functions].each do |function|
        @plugins.each { |plugin| file << plugin.mock_function_declarations(function[:name], function[:args_string], function[:rettype]) }
      end
      create_mock_header_footer(file)
    end
  end

  def create_mock_source_file(parsed_stuff)
    @file_writer.create_file(@mock_name + ".c") do |file, filename|
      create_source_header_section(file, filename, parsed_stuff[:includes])
      create_instance_structure(file, parsed_stuff[:functions])
      create_extern_declarations(file, parsed_stuff[:externs])
      create_mock_verify_function(file, parsed_stuff[:functions])
      create_mock_init_function(file)
      create_mock_destroy_function(file, parsed_stuff[:functions])
      parsed_stuff[:functions].each do |function|
        create_mock_implementation(file, function)
        @plugins.each { |plugin| file << plugin.mock_interfaces( function[:name], function[:args_string], function[:args], function[:rettype]) }
      end
    end
  end
  
  private ##############################
  
  def create_mock_header_header(file, filename) 
    define_name   = filename.gsub(/\.h/, "_h").upcase
    orig_filename = filename.gsub("Mock", "")   
    file << "/* AUTOGENERATED FILE. DO NOT EDIT. */\n"
    file << "#ifndef _#{define_name}\n"
    file << "#define _#{define_name}\n\n"
    file << "#include \"#{orig_filename}\"\n\n"
    file << "void #{@mock_name}_Init(void);\n"
    file << "void #{@mock_name}_Destroy(void);\n"
    file << "void #{@mock_name}_Verify(void);\n\n"
  end
  
  def create_mock_header_externs(header, parsed_stuff)
    unless (parsed_stuff[:externs].empty?)
      parsed_stuff[:externs].each do |extern|
        header << extern << ";\n"
      end
      header << "\n" 
    end
  end
  
  def create_mock_header_footer(header)
    header << "\n#endif\n"
  end
  
  def create_source_header_section(file, filename, include_files)
    header_file = filename.gsub(".c",".h")
    file << "/* AUTOGENERATED FILE. DO NOT EDIT. */\n"
    file << "#include <string.h>\n"
    file << "#include <stdlib.h>\n"
    file << "#include <setjmp.h>\n"
    file << "#include \"unity.h\"\n"
    @plugins.each { |plugin| file << plugin.include_files }
    
    #(@config.includes + include_files).uniq.each {|include| file << "#include \"#{include}\"\n"}  #### MSV This is what the comments said in original version, but it wasnt actually doing this
    @config.includes.each {|include| file << "#include \"#{include}\"\n"}
    file << "#include \"#{header_file}\"\n\n"
  end
  
  def create_instance_structure(file, functions)
    file << "static struct #{@mock_name}Instance\n"
    file << "{\n"
    
    if (functions.size == 0)
      file << "#{@tab}unsigned char placeHolder;\n"
    end

    file << "#{@tab}unsigned char allocFailure;\n"

    functions.each do |function|
	    @plugins.each { |plugin| file << plugin.instance_structure( function[:name], function[:args], function[:rettype] ) }
    end
    file << "} Mock;\n\n"
  end
  
  def create_extern_declarations(file, externs)
    externs.each do |extern|
      file << extern.gsub(/extern/,'') << ";\n"
    end
    file << "extern jmp_buf AbortFrame;\n"
    file << "\n"
  end
  
  def create_mock_verify_function(file, functions)
    file << "void #{@mock_name}_Verify(void)\n{\n"
    file << "#{@tab}TEST_ASSERT_EQUAL(0, Mock.allocFailure);\n"
    functions.each do |function|
      @plugins.each { |plugin| file << plugin.mock_verify(function[:name]) }
    end
    file << "}\n\n"
  end
  
  def create_mock_init_function(file)
    file << "void #{@mock_name}_Init(void)\n{\n"
    file << "#{@tab}#{@mock_name}_Destroy();\n"
    file << "}\n\n"
  end
  
  def create_mock_destroy_function(file, functions)
    file << "void #{@mock_name}_Destroy(void)\n{\n"
    functions.each do |function|
	    @plugins.each { |plugin| file << plugin.mock_destroy(function[:name], function[:args], function[:rettype]) }
    end
    file << "#{@tab}memset(&Mock, 0, sizeof(Mock));\n"
    file << "}\n\n"
  end
  
  def create_mock_implementation(file, function)
         
    # create return value combo         
    if (function[:modifier].empty?)
      function_mod_and_rettype = function[:rettype] 
    else
      function_mod_and_rettype = function[:modifier] + ' ' + function[:rettype] 
    end
    
    args_string = function[:args_string]
    args_string += (", " + function[:var_arg]) unless (function[:var_arg].nil?)
    
    # Create mock function
    file << "#{function[:attributes]} " if (!function[:attributes].nil? && function[:attributes].length > 0)
    file << "#{function_mod_and_rettype} #{function[:name]}(#{args_string})\n"
    file << "{\n"
    
    @plugins.each { |plugin| file << plugin.mock_implementation_prefix(function[:name], function[:rettype]) }
	  @plugins.each { |plugin| file << plugin.mock_implementation(function[:name], function[:args]) }
    
    # Return expected value, if necessary
    if (function[:rettype] != "void")
      file << @utils.make_handle_return(function[:name], function[:rettype], "#{@tab}")
    end
    
    # Close out the function
    file << "}\n\n"
  end
end
