$here = File.dirname __FILE__

class CMockGenerator

  attr_accessor :module_name

  def initialize(config, module_name, file_writer)
    @config = config
    @file_writer = file_writer
    @tab = @config.tab
    @module_name = module_name
    @mock_name = "Mock" + @module_name
  end

  def create_mock(parsed_stuff)
    parsed_stuff[:functions].each do |function|
      function[:args_string_without_varargs] = function[:args_string].gsub(/\,[a-zA-Z0-9_\*\s]*\.\.\./,'')
    end
    
    create_mock_header_file(parsed_stuff)
    create_mock_source_file(parsed_stuff)
  end

  def create_mock_header_file(parsed_stuff)
    @file_writer.create_file(@mock_name + ".h") do |file, filename|
      create_mock_header_header(file, filename)
      create_mock_header_externs(file, parsed_stuff)
      parsed_stuff[:functions].each do |function|
        create_mock_header_function_declaration(file, function)
      end
      create_mock_header_footer(file)
    end
  end

  def create_mock_source_file(parsed_stuff)
    @file_writer.create_file(@mock_name + ".c") do |file, filename|
      create_source_header_section(file, filename, parsed_stuff[:includes])
      create_instance_structure(file, parsed_stuff[:functions])
      create_extern_declarations(file, parsed_stuff[:externs])
      create_mock_verify_function(file, parsed_stuff[:functions])
      create_mock_init_function(file)
      create_mock_destroy_function(file, parsed_stuff[:functions])
      parsed_stuff[:functions].each do |function|
        create_mock_implementation(file, function)
        create_mock_function_expectation(file, function)
        create_mock_function_expectation_with_throw(file, function) if (@config.use_cexception)
        create_mock_function_ignore(file, function) if (@config.allow_ignore_mock)
      end
    end
  end
  
  private ##############################
  
  def create_mock_header_header(file, filename) 
    define_name   = filename.gsub(/\.h/, "_h").upcase
    orig_filename = filename.gsub("Mock", "")   
    file << "/* AUTOGENERATED FILE. DO NOT EDIT. */\n"
    file << "#ifndef _#{define_name}\n"
    file << "#define _#{define_name}\n\n"
    file << "#include \"#{orig_filename}\"\n\n"
    file << "void #{@mock_name}_Init(void);\n"
    file << "void #{@mock_name}_Destroy(void);\n"
    file << "void #{@mock_name}_Verify(void);\n\n"
  end
  
  def create_mock_header_externs(header, parsed_stuff)
    unless (parsed_stuff[:externs].empty?)
      parsed_stuff[:externs].each do |extern|
        header << extern << ";\n"
      end
      header << "\n" 
    end
  end
  
  def create_mock_header_function_declaration(header, function)

    if (function[:args].empty?)
      if (function[:rettype] == 'void')
        header << "void #{function[:name]}_Expect(void);\n"
      else
        header << "void #{function[:name]}_ExpectAndReturn(#{function[:rettype]} toReturn);\n"
      end
    else        
      if (function[:rettype] == 'void')
        header << "void #{function[:name]}_Expect(#{function[:args_string_without_varargs]});\n"
      else
        header << "void #{function[:name]}_ExpectAndReturn(#{function[:args_string_without_varargs]}, #{function[:rettype]} toReturn);\n"
      end
    end

    if (@config.use_cexception)
      if (function[:args].empty?)
        header << "void #{function[:name]}_ExpectAndThrow(int toThrow);\n"
      else        
        header << "void #{function[:name]}_ExpectAndThrow(#{function[:args_string_without_varargs]}, int toThrow);\n"
      end
    end

    if (@config.allow_ignore_mock)
      if (function[:args].empty?)
        header << "void #{function[:name]}_Ignore(void);\n"
      else        
        header << "void #{function[:name]}_IgnoreAndReturn(#{function[:rettype]} toReturn);\n"
      end    
    end
  end
  
  def create_mock_header_footer(header)
    header << "\n#endif\n"
  end
  
  def create_source_header_section(file, filename, include_files)
    header_file = filename.gsub(".c",".h")
    file << "/* AUTOGENERATED FILE. DO NOT EDIT. */\n"
    file << "#include <string.h>\n"
    file << "#include <stdlib.h>\n"
    file << "#include <setjmp.h>\n"
    file << "#include \"unity.h\"\n"
    file << "#include \"Exception.h\"\n" if (@config.use_cexception) ####MSV : REMOVE ME
    
    #(@config.includes + include_files).uniq.each {|include| file << "#include \"#{include}\"\n"}  #### MSV This is what the comments said in original version, but it wasnt actually doing this
    @config.includes.each {|include| file << "#include \"#{include}\"\n"}
    file << "#include \"#{header_file}\"\n\n"
  end
  
  def create_instance_structure(file, functions)
    file << "static struct #{@mock_name}Instance\n"
    file << "{\n"
    
    if (functions.size == 0)
      file << "#{@tab}unsigned char placeHolder;\n"
    end

    file << "#{@tab}unsigned char allocFailure;\n"

    functions.each do |function|
    
      file << "#{@tab}#{@config.call_count_type} #{function[:name]}_CallCount;\n"
      file << "#{@tab}#{@config.call_count_type} #{function[:name]}_CallsExpected;\n"
      
      if (@config.allow_ignore_mock)
        file << "#{@tab}#{@config.ignore_bool_type} #{function[:name]}_IgnoreBool;\n"
      end

      file << "#{@tab}#{@config.call_count_type} *#{function[:name]}_ThrowOnCallCount;\n"
      file << "#{@tab}#{@config.call_count_type} *#{function[:name]}_ThrowOnCallCount_Head;\n"
      file << "#{@tab}#{@config.call_count_type} *#{function[:name]}_ThrowOnCallCount_HeadTail;\n"
      file << "#{@tab}#{@config.throw_type} *#{function[:name]}_ThrowValue;\n"
      file << "#{@tab}#{@config.throw_type} *#{function[:name]}_ThrowValue_Head;\n"
      file << "#{@tab}#{@config.throw_type} *#{function[:name]}_ThrowValue_HeadTail;\n"

      if (function[:rettype] != "void")
        file << "#{@tab}#{function[:rettype]} *#{function[:name]}_Return;\n"
        file << "#{@tab}#{function[:rettype]} *#{function[:name]}_Return_Head;\n"
        file << "#{@tab}#{function[:rettype]} *#{function[:name]}_Return_HeadTail;\n"
      end

      function[:args].each do |arg|
        type = arg[:type].sub(/const/, '').strip
        file << "#{@tab}#{type} *#{function[:name]}_Expected_#{arg[:name]};\n"
        file << "#{@tab}#{type} *#{function[:name]}_Expected_#{arg[:name]}_Head;\n"
        file << "#{@tab}#{type} *#{function[:name]}_Expected_#{arg[:name]}_HeadTail;\n"
      end
    end
    file << "} Mock;\n\n"
  end
  
  def create_extern_declarations(file, externs)
    externs.each do |extern|
      file << extern.gsub(/extern/,'') << ";\n"
    end
    file << "extern jmp_buf AbortFrame;\n"
    file << "\n"
  end
  
  def create_mock_verify_function(file, functions)
    file << "void #{@mock_name}_Verify(void)\n{\n"
    file << "#{@tab}TEST_ASSERT_EQUAL(0, Mock.allocFailure);\n"
    functions.each do |function|
      file << "#{@tab}TEST_ASSERT_EQUAL_MESSAGE(Mock.#{function[:name]}_CallsExpected, Mock.#{function[:name]}_CallCount, \"Function '#{function[:name]}' called unexpected number of times.\");\n"
    end
    file << "}\n\n"
  end
  
  def create_mock_init_function(file)
    file << "void #{@mock_name}_Init(void)\n{\n"
    file << "#{@tab}#{@mock_name}_Destroy();\n"
    file << "}\n\n"
  end
  
  def create_mock_destroy_function(file, functions)
    file << "void #{@mock_name}_Destroy(void)\n{\n"
    functions.each do |function|
      if function[:rettype] != "void"
        file << "#{@tab}if(Mock.#{function[:name]}_Return_Head)\n"
        file << "#{@tab}{\n"
        file << "#{@tab}#{@tab}free(Mock.#{function[:name]}_Return_Head);\n"
        file << "#{@tab}#{@tab}Mock.#{function[:name]}_Return_Head=NULL;\n"
        file << "#{@tab}#{@tab}Mock.#{function[:name]}_Return_HeadTail=NULL;\n"
        file << "#{@tab}}\n"
      end
      function[:args].each do |arg|
        file << "#{@tab}if(Mock.#{function[:name]}_Expected_#{arg[:name]}_Head)\n"
        file << "#{@tab}{\n"
        file << "#{@tab}#{@tab}free(Mock.#{function[:name]}_Expected_#{arg[:name]}_Head);\n"
        file << "#{@tab}#{@tab}Mock.#{function[:name]}_Expected_#{arg[:name]}_Head=NULL;\n"
        file << "#{@tab}#{@tab}Mock.#{function[:name]}_Expected_#{arg[:name]}_HeadTail=NULL;\n"
        file << "#{@tab}}\n"
      end
      
      file << "#{@tab}if(Mock.#{function[:name]}_ThrowOnCallCount_Head)\n"
      file << "#{@tab}{\n"
      file << "#{@tab}#{@tab}free(Mock.#{function[:name]}_ThrowOnCallCount_Head);\n"
      file << "#{@tab}#{@tab}Mock.#{function[:name]}_ThrowOnCallCount_Head=NULL;\n"
      file << "#{@tab}#{@tab}Mock.#{function[:name]}_ThrowOnCallCount_HeadTail=NULL;\n"
      file << "#{@tab}}\n"

      file << "#{@tab}if(Mock.#{function[:name]}_ThrowValue_Head)\n"
      file << "#{@tab}{\n"
      file << "#{@tab}#{@tab}free(Mock.#{function[:name]}_ThrowValue_Head);\n"
      file << "#{@tab}#{@tab}Mock.#{function[:name]}_ThrowValue_Head=NULL;\n"
      file << "#{@tab}#{@tab}Mock.#{function[:name]}_ThrowValue_HeadTail=NULL;\n"
      file << "#{@tab}}\n"
    end
    file << "#{@tab}memset(&Mock, 0, sizeof(Mock));\n"
    file << "}\n\n"
  end
  
  def create_mock_argument_verifier(file, function)
    file << "void AssertParameters_#{function[:name]}(#{function[:args_string_without_varargs]})\n{\n"
    function[:args].each do |arg|
      type = arg[:type].sub(/const/, '').strip
      file << make_handle_expected(function, type, arg[:name])
    end
    file << "}\n\n"
  end
  
  def create_mock_implementation(file, function)
    
    newtab = "#{@tab}"
    
    # Create mock argument verifier, if necessary
    unless function[:args].empty?
      create_mock_argument_verifier(file, function)
    end
         
    # create return value combo         
    if (function[:modifier].empty?)
      function_mod_and_rettype = function[:rettype] 
    else
      function_mod_and_rettype = function[:modifier] + ' ' + function[:rettype] 
    end
    
    # Create mock function
    file << "#{function[:attributes]} " if (!function[:attributes].nil? && function[:attributes].length > 0)
    file << "#{function_mod_and_rettype} #{function[:name]}(#{function[:args_string]})\n"
    file << "{\n"
    
    # start ignore block
    if (@config.allow_ignore_mock)
      newtab = "#{@tab}#{@tab}"
      file << "#{@tab}if (!Mock.#{function[:name]}_IgnoreBool)\n"
      file << "#{@tab}{\n"    
    end
    
    file << "#{newtab}Mock.#{function[:name]}_CallCount++;\n"
    
    #create overcall protection
    exp = "Mock.#{function[:name]}_CallsExpected"
    file << "#{newtab}if (Mock.#{function[:name]}_CallCount > Mock.#{function[:name]}_CallsExpected)\n"
    file << "#{newtab}{\n"
    file << "#{newtab}#{@tab}TEST_THROW(\"#{function[:name]} Called More Times Than Expected\");\n"
    file << "#{newtab}}\n"
    
    # Create call to argument verifier, if necessary
    unless function[:args].empty?
      file << "#{newtab}AssertParameters_#{function[:name]}(#{create_call_list(function[:args])});\n"
    end
    
    # Throw exception, if appropriate
    file << make_handle_throw(function, @config.throw_type) if (@config.use_cexception)

    # end ignore block
    if (@config.allow_ignore_mock)
      file << "#{@tab}}\n"    
    end
    
    # Return expected value, if necessary
    if function[:rettype] != "void"
      file << make_handle_return(function)
    end
    
    # Close out the function
    file << "}\n\n"
  end
  
  def create_mock_function_expectation(file, function)
  
    if (function[:args].empty?)
      # Function has void return type with no arguments
      if (function[:rettype] == "void")
        file << "void #{function[:name]}_Expect(void)\n"
        file << "{\n"
        file << "#{@tab}Mock.#{function[:name]}_CallsExpected++;\n"
        file << "}\n\n"
      # Function has non-void return type with no arguments
      else
        file << "void #{function[:name]}_ExpectAndReturn(#{function[:rettype]} toReturn)\n"
        file << "{\n"
        file << "#{@tab}Mock.#{function[:name]}_CallsExpected++;\n"
        file << make_expand_array(function[:rettype], "Mock.#{function[:name]}_Return_Head", "toReturn")
        file << "#{@tab}Mock.#{function[:name]}_Return = Mock.#{function[:name]}_Return_Head;\n"
        file << "#{@tab}Mock.#{function[:name]}_Return += Mock.#{function[:name]}_CallCount;\n"
        file << "}\n\n"
      end
    else
      # Create parameter expectation function
      file << "void ExpectParameters_#{function[:name]}(#{function[:args_string_without_varargs]})\n"
      file << "{\n"
      function[:args].each do |arg|
        type = arg[:type].sub(/const/, '').strip
        file << make_add_new_expected(function, type, arg[:name])
      end
      file << "}\n\n"
      
      # Function has void return type with arguments
      if function[:rettype] == "void"
        file << "void #{function[:name]}_Expect(#{function[:args_string_without_varargs]})\n"
        file << "{\n"
        file << "#{@tab}Mock.#{function[:name]}_CallsExpected++;\n"
        file << "#{@tab}ExpectParameters_#{function[:name]}(#{create_call_list(function[:args])});\n"
        file << "}\n\n"
      # Function has non-void return type with arguments
      else
        file << "void #{function[:name]}_ExpectAndReturn(#{function[:args_string_without_varargs]}, #{function[:rettype]} toReturn)\n{\n"
        file << "#{@tab}Mock.#{function[:name]}_CallsExpected++;\n"
        file << "#{@tab}ExpectParameters_#{function[:name]}(#{create_call_list(function[:args])});\n"
        file << make_expand_array(function[:rettype], "Mock.#{function[:name]}_Return_Head", "toReturn")
        file << "#{@tab}Mock.#{function[:name]}_Return = Mock.#{function[:name]}_Return_Head;\n"
        file << "#{@tab}Mock.#{function[:name]}_Return += Mock.#{function[:name]}_CallCount;\n"
        file << "}\n\n"
      end
    end
  end
  
  def create_mock_function_expectation_with_throw(file, function)
    
    # function takes no arguments
    if (function[:args].empty?)
      file << "void #{function[:name]}_ExpectAndThrow(#{@config.throw_type} toThrow)\n"
      file << "{\n"
      file << "#{@tab}Mock.#{function[:name]}_CallsExpected++;\n"
      file << make_expand_array(@config.call_count_type, "Mock.#{function[:name]}_ThrowOnCallCount_Head", "Mock.#{function[:name]}_CallsExpected")
      file << "#{@tab}Mock.#{function[:name]}_ThrowOnCallCount = Mock.#{function[:name]}_ThrowOnCallCount_Head;\n"
      file << "#{@tab}Mock.#{function[:name]}_ThrowOnCallCount += Mock.#{function[:name]}_CallCount;\n"
      file << make_expand_array(@config.throw_type, "Mock.#{function[:name]}_ThrowValue_Head", "toThrow")
      file << "#{@tab}Mock.#{function[:name]}_ThrowValue = Mock.#{function[:name]}_ThrowValue_Head;\n"      
      file << "#{@tab}Mock.#{function[:name]}_ThrowValue += Mock.#{function[:name]}_CallCount;\n"
      file << "}\n\n"
    else
      file << "void #{function[:name]}_ExpectAndThrow(#{function[:args_string_without_varargs]}, #{@config.throw_type} toThrow)\n"
      file << "{\n"
      file << "#{@tab}Mock.#{function[:name]}_CallsExpected++;\n"
      file << make_expand_array(@config.call_count_type, "Mock.#{function[:name]}_ThrowOnCallCount_Head", "Mock.#{function[:name]}_CallsExpected")
      file << "#{@tab}Mock.#{function[:name]}_ThrowOnCallCount = Mock.#{function[:name]}_ThrowOnCallCount_Head;\n"
      file << "#{@tab}Mock.#{function[:name]}_ThrowOnCallCount += Mock.#{function[:name]}_CallCount;\n"
      file << make_expand_array(@config.throw_type, "Mock.#{function[:name]}_ThrowValue_Head", "toThrow")
      file << "#{@tab}Mock.#{function[:name]}_ThrowValue = Mock.#{function[:name]}_ThrowValue_Head;\n"      
      file << "#{@tab}Mock.#{function[:name]}_ThrowValue += Mock.#{function[:name]}_CallCount;\n"
      file << "#{@tab}ExpectParameters_#{function[:name]}(#{create_call_list(function[:args])});\n"
      file << "}\n\n"
    end
  end
  
  def create_mock_function_ignore(file, function)
    # Function has void return type with no arguments
    if function[:rettype] == "void"
      file << "void #{function[:name]}_Ignore(void)\n"
      file << "{\n"
      file << "#{@tab}Mock.#{function[:name]}_IgnoreBool = (unsigned char)1;\n"
      file << "}\n\n"
    # Function has non-void return type with no arguments
    else
      file << "void #{function[:name]}_IgnoreAndReturn(#{function[:rettype]} toReturn)\n"
      file << "{\n"
      file << "#{@tab}Mock.#{function[:name]}_IgnoreBool = (unsigned char)1;\n"
      file << make_expand_array(function[:rettype], "Mock.#{function[:name]}_Return_Head", "toReturn")
      file << "#{@tab}Mock.#{function[:name]}_Return = Mock.#{function[:name]}_Return_Head;\n"
      file << "#{@tab}Mock.#{function[:name]}_Return += Mock.#{function[:name]}_CallCount;\n"
      file << "}\n\n"
    end
  end
  
  def create_call_list(args)
    call_list = ""
    args.each do |arg|
      if call_list.empty?
        call_list = arg[:name]
      else
        call_list += ", " + arg[:name]
      end
    end
    return call_list
  end
  
  def make_expand_array(type, array, newValue)
    <<EOS

#{@tab}{
#{@tab}#{@tab}int sz = 0;
#{@tab}#{@tab}#{type} *pointer = #{array};
#{@tab}#{@tab}while(pointer && pointer != #{array}Tail) { sz++; pointer++; }
#{@tab}#{@tab}if(sz == 0)
#{@tab}#{@tab}{
#{@tab}#{@tab}#{@tab}#{array} = (#{type}*)malloc(2*sizeof(#{type}));
#{@tab}#{@tab}#{@tab}if(!#{array})
#{@tab}#{@tab}#{@tab}#{@tab}Mock.allocFailure++;
#{@tab}#{@tab}}
#{@tab}#{@tab}else
#{@tab}#{@tab}{
#{@tab}#{@tab}#{@tab}#{type} *ptmp = (#{type}*)realloc(#{array}, sizeof(#{type}) * (sz+1));
#{@tab}#{@tab}#{@tab}if(!ptmp)
#{@tab}#{@tab}#{@tab}#{@tab}Mock.allocFailure++;
#{@tab}#{@tab}#{@tab}else
#{@tab}#{@tab}#{@tab}#{@tab}#{array} = ptmp;
#{@tab}#{@tab}}
#{@tab}#{@tab}memcpy(&#{array}[sz], &#{newValue}, sizeof(#{type}));
#{@tab}#{@tab}#{array}Tail = &#{array}[sz+1];
#{@tab}}
EOS
  end

  def make_handle_throw(function, throw_type)
  
    newtab = "#{@tab}"
    method = function[:name]
    
    if (@config.allow_ignore_mock)
      newtab = "#{@tab}#{@tab}"
    end
  
    <<EOS

#{newtab}if((Mock.#{method}_ThrowOnCallCount != Mock.#{method}_ThrowOnCallCount_HeadTail) &&
#{newtab}#{@tab}(Mock.#{method}_ThrowValue != Mock.#{method}_ThrowValue_HeadTail))
#{newtab}{
#{newtab}#{@tab}if (*Mock.#{function[:name]}_ThrowOnCallCount && 
#{newtab}#{@tab}#{@tab}(Mock.#{function[:name]}_CallCount == *Mock.#{function[:name]}_ThrowOnCallCount))
#{newtab}#{@tab}{
#{newtab}#{@tab}#{@tab}#{throw_type} toThrow = *Mock.#{function[:name]}_ThrowValue;
#{newtab}#{@tab}#{@tab}Mock.#{function[:name]}_ThrowOnCallCount++;
#{newtab}#{@tab}#{@tab}Mock.#{function[:name]}_ThrowValue++;
#{newtab}#{@tab}#{@tab}Throw(toThrow);
#{newtab}#{@tab}}
#{newtab}}
EOS
  end
    
  def make_handle_return(function)
  
    method = function[:name]
    return_block = <<EOS

#{@tab}if(Mock.#{method}_Return != Mock.#{method}_Return_HeadTail)
#{@tab}{
#{@tab}#{@tab}#{function[:rettype]} toReturn = *Mock.#{method}_Return;
#{@tab}#{@tab}Mock.#{method}_Return++;
#{@tab}#{@tab}return toReturn;
#{@tab}}
#{@tab}else
#{@tab}{
#{@tab}#{@tab}return *Mock.#{method}_Return_Head;
#{@tab}}
EOS
    return return_block
  end

  def make_add_new_expected(function, type, expected)
    method = function[:name]
    array = make_expand_array(type, "Mock.#{method}_Expected_#{expected}_Head", expected)
    array = "#{array}" + "#{@tab}Mock.#{method}_Expected_#{expected} = Mock.#{method}_Expected_#{expected}_Head;\n"
    return "#{array}" + "#{@tab}Mock.#{method}_Expected_#{expected} += Mock.#{function[:name]}_CallCount;\n"
  end

  def make_handle_expected(function, type, actual)

    method = function[:name]
    if (type == "char*" || type == "const char*")
      code_block = <<EOS

#{@tab}if(Mock.#{method}_Expected_#{actual} != Mock.#{method}_Expected_#{actual}_HeadTail)
#{@tab}{
#{@tab}#{@tab}#{type}* p_expected = Mock.#{method}_Expected_#{actual};
#{@tab}#{@tab}Mock.#{method}_Expected_#{actual}++;
#{@tab}#{@tab}TEST_ASSERT_EQUAL_STRING_MESSAGE(*p_expected, #{actual}, \"Function '#{method}' called with unexpected string for parameter '#{actual}'.\");
#{@tab}}
EOS
    else
      code_block = <<EOS

#{@tab}if(Mock.#{method}_Expected_#{actual} != Mock.#{method}_Expected_#{actual}_HeadTail)
#{@tab}{
#{@tab}#{@tab}#{type}* p_expected = Mock.#{method}_Expected_#{actual};
#{@tab}#{@tab}Mock.#{method}_Expected_#{actual}++;
#{@tab}#{@tab}TEST_ASSERT_EQUAL_MESSAGE(*p_expected, #{actual}, \"Function '#{method}' called with unexpected value for parameter '#{actual}'.\");
#{@tab}}
EOS
    end

    return code_block
  end
end
