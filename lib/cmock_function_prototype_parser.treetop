grammar CMockFunctionPrototype

  rule function_prototype
		  function_prototype_function_pointer_return / function_prototype_standard
	end
	
  rule function_prototype_standard
    return_type name argument_list <FunctionPrototypeStandardNode>
  end
  
  rule function_prototype_function_pointer_return
    # ex. float (*GetPtr(const char opCode))(float, float)
    # const: tag so we can always access its nodes in programming even if blank
    return_type
    left_paren asterisk name function_arglist:argument_list right_paren
    function_return_arglist:argument_list
    <FunctionPrototypeFunctionPointerReturnNode>
  end

  rule return_type
    # void is different than the type possibility 'void*'
    void / type
  end

  rule argument_list
    # without a priori knowledge of all custom types (i.e. typedefs), the parser can only recognize
    # a list of primitives followed by an optional name or a single custom type followed by an optional name.
    # otherwise, there's no way to distinguish the last type in a list from a possibly non-existent argument name;
    # the rules in the grammar enforce this idea to ensure the parser fails rather than do something wonky
    left_paren arguments:( argument:argument (comma)? )* right_paren <ArgumentListNode>
  end

  rule argument
    func_ptr_prototype / void / type_and_name / variable_argument
  end
    
  rule variable_argument
    '...' space_optional <VarArgNode>
  end

  rule func_ptr_prototype
    # ex. int (*funcPtr)(float, char, char)
    return_type name_and_args:parenthesized_func_ptr_name_with_arglist <FunctionPointerNode>
  end

  rule parenthesized_func_ptr_name_with_arglist
    # - allow nested parentheses around name and arglist
    # - use labels 'const:' and 'name:' to give programmatic access even if nodes aren't found in string
    (left_paren name_and_args:parenthesized_func_ptr_name_with_arglist right_paren) /
    (left_paren asterisk const:const? name:name? right_paren argument_list)
  end

  rule type_and_name
    # - name? tagged with name: so we can always access it in programming even if blank
    # - tell parser that type and optional name will always be followed by ',' '(' or ')' but don't consume them;
    #   this helps enforce the limits on what can be parsed in argument lists
    type name:name_with_brackets? &( comma / left_paren / right_paren ) <TypeWithNameNode>
  end

  rule type
    const?
    ( type_struct_union_enum /
      type_void_ptr /
      type_primitive /
      type_custom )
    brackets:array_brackets? <TypeNode>
  end

  rule type_struct_union_enum
    ('struct' / 'union' / 'enum') space_mandatory name_no_space type_const_and_ptr_suffix? space_optional
  end

  rule type_void_ptr
    # note that type_const_and_ptr_suffix is mandatory unlike other type rules because 
    # rule represents void pointer (i.e. must contain a '*' by definition)
    'void' type_const_and_ptr_suffix space_optional
  end

  rule type_primitive
    # - at least one clause has to exist, not all can be '?' optional;
    #   hence the long and int variations instead of an optional long followed by optional everything else
    # - !name_no_space limits matches to only primitives allowing custom types to be successfully 
    #   recognized though their strings may begin with primitives (ex. integer value1, character value2)
    (('unsigned' / 'signed') space_mandatory)?
    (('long' space_mandatory 'int') / ('long' space_mandatory 'long') / 'long' / 'int' / 'short' / 'char' / 'float' / 'double') !name_no_space
    type_const_and_ptr_suffix?
    space_optional
  end

  rule type_custom
    name_no_space type_const_and_ptr_suffix? space_optional
  end

  rule type_const_and_ptr_suffix
    # variants of "const", "const *", "* const", "const * const", & "*"
    # (of course, more than one asterisk possible in pointer cases)
    (space_mandatory const asterisk+ lookahead_const) /
    (space_mandatory const asterisk+) /
    (space_optional asterisk+ lookahead_const) /
    (space_optional asterisk+) / 
    (space_optional lookahead_const)
  end

  rule lookahead_const
    # fancy lookahead statement that allows const type suffix to be distinguished from a parameter 
    # name that might begin with word 'const' (ex. "int const_param" or "char* const constant")
    'const' ( (space_mandatory &name) / (space_optional &comma) / (space_optional &right_paren) / (space_optional &left_paren) )
  end

	rule name
	  alpha_numeric+ space_optional <NameWithSpaceNode>
	end

	rule name_no_space
	  alpha_numeric+
	end

  rule name_with_brackets
    name brackets:array_brackets? <NameWithBracketsNode>
  end

  rule void
    # in reality, 'void' is different than 'void*' type so limit to 'void' here and handle 'void*' in type rule;
    # recognizing the VoidNode uniquely in programming is helpful
    'void' space_optional !asterisk <VoidNode>
  end
  
  rule array_brackets
    left_bracket right_bracket (left_bracket number right_bracket)* <ArrayBracketsNode>
  end

  rule const
    'const' space_optional
  end

  rule asterisk
    '*' space_optional
  end

  rule left_paren
    '(' space_optional
  end

  rule right_paren
    ')' space_optional
  end

  rule left_bracket
    '[' space_optional
  end

  rule right_bracket
    ']' space_optional
  end

  rule comma
    ',' space_optional
  end

  rule alpha_numeric
    [a-zA-Z0-9_]
  end

  rule number
    [0-9] space_optional
  end

  rule space_mandatory
    ' '+
  end

  rule space_optional
    ' '*
  end
  
end
